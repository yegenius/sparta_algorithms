current_r, current_c, current_d = 7, 4, 0
current_room_map = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
'''1. 현재 위치를 청소한다. 
→ 현재 위치를 청소했는지 아닌지에 대해서 저장을 해야 합니다! 
bfs 를 구현할 때는 visited 에 저장을 했는데, 그 때는 각 노드를 1차원 배열에 저장했습니다.
이번에는 2차원 배열에 맵 정보가 저장되니까, 이를 활용해보겠습니다!

0 은 청소하지 않은 장소,
1은 청소하지 못하는 장소,
2는 청소한 장소! 로 기록해둡시다.

2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
→ 이 문제는 "방향" 이라는 개념이 존재합니다. 즉, 왼쪽방향으로 회전한다는 개념을 구현해야 합니다.

이를 위해서 북, 동, 남, 서 순서를 정의해보겠습니다!
     r   c
북   -1  0
동   0   1
남   1   0
서   0  -1

이 정보를 아래와 같이 배열에 담아둡니다.
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1] 
북쪽이면 0 번째 인덱스이므로 dr[0], dc[0] 을 사용해 이동하면 -1, 0 을 이동합니다.
동쪽이면 1 번째 인덱스이므로 dr[1], dc[1] 을 사용해 이동하면 0, 1 을 이동합니다.
이런식으로 방향 개념을 정의할 수 있습니다!

a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
→ 회전은 어떻게 구현할 수 있을까요? 왼쪽 방향으로 회전을 하기 위해서는 
아까 만든 방향을 사용하시면 됩니다!
북쪽에서 왼쪽으로 회전하면? 서쪽이 됩니다. 즉, 0번째 인덱스가 3이 됩니다.
동쪽에서 왼쪽으로 회전하면? 북쪽이 됩니다. 즉, 1번째 인덱스가 0이 됩니다.
남쪽에서 왼쪽으로 회전하면? 동쪽이 됩니다. 즉, 2번째 인덱스가 1이 됩니다.
서쪽에서 왼쪽으로 회전하면? 남쪽이 됩니다. 즉, 3번째 인덱스가 2가 됩니다.

rotate 라는 함수를 쓰면 방향의 인덱스가 +3 % 4 한다는 것을 알 수 있습니다!

b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
→ 현재 본 방향에서 청소할 곳이 없다면 다시 한 번 왼쪽으로 회전하라! 라는 의미입니다. 즉 회전하면서 모든 방향에서 청소할 곳이 있는지 확인하라는 의미입니다.

c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
→ 모든 방향이 청소되어있다면 뒤로 한 칸 후진합니다. 
후진도 방향에 따라 후진하는 게 다릅니다. 한 번 같이 생각해볼게요!
북쪽에서 후진하면? 남쪽이 됩니다. 즉, 0번째 인덱스가 2이 됩니다.
동쪽에서 후진하면? 서쪽이 됩니다. 즉, 1번째 인덱스가 3이 됩니다.
남쪽에서 후진하면? 북쪽이 됩니다. 즉, 2번째 인덱스가 0이 됩니다.
서쪽에서 후진하면? 동쪽이 됩니다. 즉, 3번째 인덱스가 1이 됩니다. 
이걸 수식으로 나타내면 +2 % 4 입니다!

d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
→ 만약 모든 방향을 다 봤는데 갈 곳이 없고 뒤에도 벽이라면 멈추면 됩니다!

이렇게 위의 개념들을 그대로 구현하시면 됩니다!'''

# 북 동 남 서
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]


# 방향 전환
def get_d_index_when_rotate_to_left(d):
    return (d + 3) % 4


# 후진
def get_d_index_when_go_back(d):
    return (d + 2) % 4


def get_count_of_departments_cleaned_by_robot_vacuum(r, c, d, room_map):
    n = len(room_map)
    m = len(room_map[0])
    count_of_departments_cleaned = 1  # 청소하는 칸의 개수
    room_map[r][c] = 2
    queue = list([[r, c, d]])

    # 큐가 비어지면 종료
    while queue:
        r, c, d = queue.pop(0)
        temp_d = d

        for i in range(4):
            temp_d = get_d_index_when_rotate_to_left(temp_d)
            new_r, new_c = r + dr[temp_d], c + dc[temp_d]

            # a
            if 0 <= new_r < n and 0 <= new_c < m and room_map[new_r][new_c] == 0:
                count_of_departments_cleaned += 1
                room_map[new_r][new_c] = 2
                queue.append([new_r, new_c, temp_d])
                break

            # c
            elif i == 3:  # 갈 곳이 없었던 경우
                new_r, new_c = r + dr[get_d_index_when_go_back(d)], c + dc[get_d_index_when_go_back(d)]
                queue.append([new_r, new_c, d])

                # d
                if room_map[new_r][new_c] == 1:  # 뒤가 벽인 경우
                    return count_of_departments_cleaned


print(get_count_of_departments_cleaned_by_robot_vacuum(current_r, current_c, current_d, current_room_map))
current_room_map2 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
print("정답 = 29 / 현재 풀이 값 = ", get_count_of_departments_cleaned_by_robot_vacuum(6,3,1,current_room_map2))
current_room_map3 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
print("정답 = 33 / 현재 풀이 값 = ", get_count_of_departments_cleaned_by_robot_vacuum(7,4,1,current_room_map3))
current_room_map4 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
print("정답 = 25 / 현재 풀이 값 = ", get_count_of_departments_cleaned_by_robot_vacuum(6,2,0,current_room_map4))